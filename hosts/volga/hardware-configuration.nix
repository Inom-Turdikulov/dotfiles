# Do not modify this file!  It was generated by ‘nixos-generate-config’
# and may be overwritten by future invocations.  Please make changes
# to /etc/nixos/configuration.nix instead.
{ config, lib, pkgs, modulesPath, ... }:

{
  imports =
    [ (modulesPath + "/installer/scan/not-detected.nix")
    ];

  boot = {
    initrd.availableKernelModules = [ "amdgpu" "vfio-pci" "nvme" "xhci_pci" "ahci" "usb_storage" "usbhid" "sd_mod" ];

    initrd.preDeviceCommands = ''
  DEVS="0000:12:00.0 0000:12:00.1"
  for DEV in $DEVS; do
    echo "vfio-pci" > /sys/bus/pci/devices/$DEV/driver_override
  done
  modprobe -i vfio-pci
    '';

    initrd.kernelModules = [];
    extraModulePackages = [];
    extraModprobeConfig ="options vfio-pci ids=1002:73ff,1002:ab28";
    kernelModules = [ "vfio" "vfio_iommu_type1" "vfio_pci" "vfio_virqfd" "kvm-amd" ];
    kernelParams = [
      # HACK Disables fixes for spectre, meltdown, L1TF and a number of CPU
      #      vulnerabilities. Don't copy this blindly! And especially not for
      #      mission critical or server/headless builds exposed to the world.
      "mitigations=off"
      "amdgpu.noretry=0"
      "amd_iommu=on"
    ];

    # Refuse ICMP echo requests on my desktop/laptop; nobody has any business
    # pinging them, unlike my servers.
    kernel.sysctl."net.ipv4.icmp_echo_ignore_broadcasts" = 1;
  };

  # Displays
  # services.xserver = {
  #   # This must be done manually to ensure my screen spaces are arranged exactly
  #   # as I need them to be *and* the correct monitor is "primary". Using
  #   # xrandrHeads does not work.
  #   monitorSection = ''
  #     VendorName     "Unknown"
  #     ModelName      "Asus VZ239"
  #     Option         "DPMS"
  #     Modeline "1920x1080_60.00" 220.64 1920 2056 2264 2608 1080 1081 1084 1128 -HSync +Vsync
  #     Option "PreferredMode" "1920x1080_60.00"
  #   '';
  #   screenSection = ''
  #     SubSection "Display"
  #       Modes "1920x1080_60.00"
  #     EndSubSection
  #   '';
  # };

  services.autorandr = {
    enable = true;
    profiles =   {
      "default" = {
        fingerprint = {
          HDMI-1 = "00ffffffffffff0006b3cc2301010101101f010380331d78ead905a557519e270f5054afcf80714f8180818fb30081409500a9408bc0023a801871382d40582c4500fd1e1100001e000000fd00304c1e5511000a202020202020000000fc00565a3233390a20202020202020000000ff004d344c4d52533030383639390a0145020315f14a900403011412051f101365030c0010002a4480a07038274030203500fd1e1100001a011d8018711c1620582c2500fd1e1100009e011d007251d01e206e285500fd1e1100001e8c0ad08a20e02d10103e9600fd1e110000180000000000000000000000000000000000000000000000000000000000000000000055";
        };
        config = {
          HDMI-1 = {
            enable = true;
            primary = true;
            position = "0x0";
            mode = "1920x1080";
            rate = "60.00";
          };
        };
      };
    };
  };

  systemd.user.services."autorandr_load" = {
    description = "autorandr";
    after = [ "graphical-session-pre.target" ];
    partOf = [ "graphical-session.target" ];
    wantedBy = [ "graphical-session.target" ];

    serviceConfig = {
      # optionally add --ignore-lid
      ExecStart = "${pkgs.autorandr}/bin/autorandr --change";
      Type = "oneshot";
    };
  };

  # NixOS hardware options
  hardware = {
    xpadneo.enable = true;      # Xbox controller support
    onlykey.enable = true;      # Enable OnlyKey device
  };

  # Custom hardware options
  modules.hardware = {
    audio.enable = true;
    wacom.enable = true;
    bluetooth.enable = true;
    radeon.enable = true;
    microcontroller.enable = true;
    qmk.enable = true;
    android.enable = true;
    fs = {
      enable = true;
      ssd.enable = false;  # I use instead discard=async with BTRFS
    };
    sensors.enable = true;
    utilites.enable = true; # hardware utilities like lshw and geekbench
  };

  fileSystems."/" =
    { device = "/dev/disk/by-uuid/be3fc6b1-d2d0-4c37-ab40-53567d54e67d";
      fsType = "btrfs";
      options = [ "subvol=root" "compress=zstd" ];
    };

  fileSystems."/boot" =
    { device = "/dev/disk/by-uuid/EF8C-D8DA";
      fsType = "vfat";
    };

  fileSystems."/home" =
    { device = "/dev/disk/by-uuid/be3fc6b1-d2d0-4c37-ab40-53567d54e67d";
      fsType = "btrfs";
      options = [ "subvol=home" "compress=zstd" ];
    };

  fileSystems."/nix" =
    { device = "/dev/disk/by-uuid/be3fc6b1-d2d0-4c37-ab40-53567d54e67d";
      fsType = "btrfs";
      options = [ "subvol=nix" "compress=zstd" ];
    };

  fileSystems."/games" =
    { device = "/dev/disk/by-uuid/be3fc6b1-d2d0-4c37-ab40-53567d54e67d";
      fsType = "btrfs";
      options = [ "subvol=games" "compress=zstd" ];
    };

  fileSystems."${config.user.home}/Downloads" =
    { device = "/dev/disk/by-uuid/908dd11f-7265-425f-8b6e-f041fe69b0ba";
      fsType = "btrfs";
      options = [ "subvol=downloads" ];
    };

  fileSystems."${config.user.home}/Virtual_Machines" =
    { device = "/dev/disk/by-uuid/908dd11f-7265-425f-8b6e-f041fe69b0ba";
      fsType = "btrfs";
      options = [ "subvol=virtual-machines" ];
    };

  fileSystems."/archive" =
    { device = "/dev/disk/by-uuid/ff1ddb67-6528-49b3-8159-3d26eb97d431";
      fsType = "btrfs";
      options = [ "subvol=root" "compress=zstd" ];
    };

  swapDevices = [ ];

  # CPU
  nix.settings.max-jobs = lib.mkDefault 12;
  powerManagement.cpuFreqGovernor = "performance";
  hardware.cpu.amd.updateMicrocode = true;

  # Enables DHCP on each ethernet and wireless interface. In case of scripted networking
  # (the default) this is the recommended approach. When using systemd-networkd it's
  # still possible to use this option, but it's recommended to use it in conjunction
  # with explicit per-interface declarations with `networking.interfaces.<interface>.useDHCP`.
  networking.useDHCP = lib.mkDefault true;
  # networking.interfaces.enp34s0.useDHCP = lib.mkDefault true;

  nixpkgs.hostPlatform = lib.mkDefault "x86_64-linux";
}